<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UE学习笔记 | Aozi</title><meta name="author" content="Aozi"><meta name="copyright" content="Aozi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视口操作End吸附到地面G隐藏场景中的非游戏物体F将镜头跳转到世界大纲中选中的物体 UE_LOG123    UE_LOG(LogTemp,Display, TEXT(&quot;hello,world&quot;));    UE_LOG(LogTemp, Warning, TEXT(&quot;hello,world&quot;));    UE_LOG(LogTemp, Error, TEX">
<meta property="og:type" content="website">
<meta property="og:title" content="UE学习笔记">
<meta property="og:url" content="https://wza0409.github.io/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Notes/UnrealEngine/UE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="Aozi">
<meta property="og:description" content="视口操作End吸附到地面G隐藏场景中的非游戏物体F将镜头跳转到世界大纲中选中的物体 UE_LOG123    UE_LOG(LogTemp,Display, TEXT(&quot;hello,world&quot;));    UE_LOG(LogTemp, Warning, TEXT(&quot;hello,world&quot;));    UE_LOG(LogTemp, Error, TEX">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wza0409.github.io/img/background.jpg">
<meta property="article:published_time" content="2023-11-19T06:23:02.000Z">
<meta property="article:modified_time" content="2024-03-14T13:30:31.053Z">
<meta property="article:author" content="Aozi">
<meta property="article:tag" content="Notes">
<meta property="article:tag" content="UE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wza0409.github.io/img/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wza0409.github.io/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/Notes/UnrealEngine/UE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"简","msgToSimplifiedChinese":"繁"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE学习笔记',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-03-14 21:30:31'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/background.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/Timeline/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Works/ImgsForWorks/"><i class="fa-fw fa-solid fa-book"></i><span> 作品集</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 成长之旅</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/Blender/"><span> Blender</span></a></li><li><a class="site-page child" href="/Notes/Cpp/"><span> C++</span></a></li><li><a class="site-page child" href="/Notes/Design/"><span> Design</span></a></li><li><a class="site-page child" href="/Notes/Modding/"><span> Modding</span></a></li><li><a class="site-page child" href="/Notes/SubstancePainter/"><span> SubstancePainter</span></a></li><li><a class="site-page child" href="/UnrealEngine/"><span> Unreal Engine</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Aozi"><span class="site-name">Aozi</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/Timeline/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/Works/ImgsForWorks/"><i class="fa-fw fa-solid fa-book"></i><span> 作品集</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 成长之旅</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/Blender/"><span> Blender</span></a></li><li><a class="site-page child" href="/Notes/Cpp/"><span> C++</span></a></li><li><a class="site-page child" href="/Notes/Design/"><span> Design</span></a></li><li><a class="site-page child" href="/Notes/Modding/"><span> Modding</span></a></li><li><a class="site-page child" href="/Notes/SubstancePainter/"><span> SubstancePainter</span></a></li><li><a class="site-page child" href="/UnrealEngine/"><span> Unreal Engine</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="page"><h1 class="page-title">UE学习笔记</h1><div id="article-container"><p>视口操作<br><code>End</code>吸附到地面<br><code>G</code>隐藏场景中的非游戏物体<br><code>F</code>将镜头跳转到世界大纲中选中的物体</p>
<h1 id="UE-LOG"><a href="#UE-LOG" class="headerlink" title="UE_LOG"></a>UE_LOG</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp,Display, <span class="built_in">TEXT</span>(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(“hello,world<span class="string">&quot;));</span></span><br></pre></td></tr></table></figure>



<p>如果要输出列表内容，需要使用格式化控制字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;variable %d&quot;</span>),cnt);</span><br></pre></td></tr></table></figure>
<p>int <code>%d</code>或<code>%i</code><br>float <code>%f</code>  使用<code>%.2f</code>表示显示到小数点后一位<br>bool <code>%d</code> 即int<br>Fstring <code>%s</code></p>
<p><code>TEXT</code>宏是一个字符串的包装器，它返回一个扩展的字符串来使用Unicode字符集</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_LOG_CATEGORY_STATIC(CategoryName, DefaultVerbosity, CompileTimeVerbosity)<span class="comment">//C++静态，只在定义所处的文件中生效</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity)<span class="comment">//在头文件中声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_LOG_CATEGORY(CategoryName)<span class="comment">//在cpp文件中定义</span></span></span><br><span class="line"><span class="comment">//使用EXTERN可以将自定义的LOG类别放在自己的文件中，并在需要的地方#include </span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY_STATIC</span>(LogBaseGeometry, Error,Error) </span><br></pre></td></tr></table></figure>
<p>将不会输出详细程度比Error高的日志,即下面的代码会被忽略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UE_LOG</span>(LogBaseGeometry,Warning,<span class="built_in">TXEX</span>(<span class="string">&quot;MyMessage&quot;</span>))；</span><br></pre></td></tr></table></figure>

<h1 id="FString"><a href="#FString" class="headerlink" title="FString"></a>FString</h1><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.3/en-US/fstring-in-unreal-engine/">UE4.26官方文档</a><br>FStrings constructed with FString::Printf can be stored into FStrings, as well as displayed to the screen with UE_LOG debug messaging.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FString MyName = <span class="string">&quot;Aozi&quot;</span>;</span><br><span class="line"><span class="type">float</span> MyHealth = <span class="number">100.0f</span>;</span><br><span class="line">FString State = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;My Name: %s \nMy Health: %f&quot;</span>), *MyName, MyHealth); <span class="comment">//Store into FString</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;My State: %s&quot;</span>), *State);</span><br></pre></td></tr></table></figure>

<h1 id="简单的移动"><a href="#简单的移动" class="headerlink" title="简单的移动"></a>简单的移动</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在.cpp文件中</span></span><br><span class="line"><span class="comment">//事前声明了InitLocation和CurrentLocation,并在BeginPlay()中：InitLocation = GetActorLocation();</span></span><br><span class="line">CurrentLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">CurrentLocation.Z = InitLocation.Z + Amplitude * FMath::<span class="built_in">Sin</span>(Frequency * (<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>())); </span><br><span class="line"><span class="comment">//GetWorld()返回一个指向全局对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SetActorLocation</span>(CurrentLocation);</span><br></pre></td></tr></table></figure>

<h1 id="UE材质"><a href="#UE材质" class="headerlink" title="UE材质"></a>UE材质</h1><p>Material和Material_Inst  使得我们可以用一个材质创建出一组不同的类似的材质</p>
<p>##使用C++动态设置(静态网格体的)材质</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个颜色参数，使得我们可以在编辑器中修改</span></span><br><span class="line">FLinearColor::BaseColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用CreateDynamicMaterialInstance该方法将为静态网格体组件的材质创建一个动态材质，并返回一个指向该动态材质的指针(UMaterialInstance*)</span></span><br><span class="line">UMaterialInstance * DynamicMaterial = BaseMesh-&gt; <span class="built_in">CreateAndSetMaterialInstanceDynamic</span>(<span class="number">0</span>);<span class="comment">//对于静态网格体而言，只有一种材质</span></span><br><span class="line"><span class="comment">//检查指针的有效性,并设置材质的基础颜色</span></span><br><span class="line"><span class="keyword">if</span> (DynamicMaterial)</span><br><span class="line">&#123;</span><br><span class="line">	DynamicMaterial-&gt;<span class="built_in">SetVectorParameterValue</span>(<span class="string">&quot;BaseColor&quot;</span>, BaseColor); <span class="comment">//&quot;BaseColor&quot;为该静态网格体材质的FNamne</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FLinearColar是32位颜色，FColor是8位颜色</span></span><br></pre></td></tr></table></figure>

<h1 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h1><p>在.cpp文件中添加”TimerManager.h”头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> TimerRater = <span class="number">3.0f</span>; <span class="comment">//负责计时器的频率</span></span><br><span class="line">FTimerHandle TimerHandle；<span class="comment">//timerdescriptor，唯一地标识计时器，使我们可以访问计时器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnTimerFired</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//每次计时器启动时都会调用此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该全局静态函数返回一个计时器管理器(TimerManager)对象,我们使用它地SetTimer()函数初始化计时器</span></span><br><span class="line"><span class="comment">//FORCEINLINE void SetTimer(FTimerHandle&amp; InOutHandle, UserClass* InObj, typename FTimerDelegate::TUObjectMethodDelegate&lt; UserClass &gt;::FMethodPtr InTimerMethod, float InRate, bool InbLoop = false, float InFirstDelay = -1.f)</span></span><br><span class="line"><span class="comment">//第二个参数是指向一个对象的指针，每次计时器触发时，调用该对象的函数；第三个参数是每次计时器触发要调用的函数;第四个参数是计时器的频率，第五个参数是判断计时器循环与否</span></span><br></pre></td></tr></table></figure>

<h1 id="动态Actor的创建-Dynamic-Actor-Creation"><a href="#动态Actor的创建-Dynamic-Actor-Creation" class="headerlink" title="动态Actor的创建(Dynamic Actor Creation)"></a>动态Actor的创建(Dynamic Actor Creation)</h1><p>我们需要一个额外的Actor，称之为Hub，负责创建BaseGeometryActor的actors</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//头文件中声明一个指向我们想要创建的Actor类的指针</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line"><span class="built_in">TSubClassOf</span>(ABaseGeometryActor) GeometryClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先包含头文件&quot;Engine/World.h&quot;,并获取World指针</span></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用World指针生成Actor,SpawnActor()默认单位缩放，无旋转，在远点生成,返回AAcotr*</span></span><br><span class="line"><span class="keyword">if</span>(World)</span><br><span class="line">&#123;</span><br><span class="line">	World-&gt;<span class="built_in">SpawnActor</span>(GeometryClalss); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板版本的SpawnActor&lt;&gt;()返回特定的Actor* </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABaseGeometryActor* Geometry = World-&gt;<span class="built_in">SpawnActor</span>&lt;ABaseGeometryActor&gt;(GeometryClass);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//生成Actor的坐标</span></span><br><span class="line">	<span class="type">const</span> FTransform BaseGeometryActorTransform = <span class="built_in">FTransform</span>(<span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">300.0f</span>*i, <span class="number">300.0f</span>));</span><br><span class="line">	<span class="comment">//使用World调用SpawnActor方法生成Actor，该方法返回所指定的Actor指针，没有指定就返回AActor*</span></span><br><span class="line">	ABaseGeometryActor* BaseGeometryActor = World-&gt;<span class="built_in">SpawnActor</span>&lt;ABaseGeometryActor&gt;(GeometryClass, BaseGeometryActorTransform);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>补充：几种属性<br>起到过滤作用，在编辑面板中将只显示所选的类及其子类(包括蓝图类)，即该指针只能指向所选的类及其子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">TSubclassOf&lt;ABaseGeometryActor&gt; GeometryClass;</span><br></pre></td></tr></table></figure>
<p>该指针可指向舞台上存在的所有类，在编辑面板中可选择所有的类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UClass* Class;</span><br></pre></td></tr></table></figure>
<p>只能指向舞台上存在的ABaseGeometryActor类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">ABaseGeometryActor* GeometryObject;</span><br></pre></td></tr></table></figure>

<p>补充：关于FTransform<br>    FTransform是一个结构体,包含Rotation，Location和Scale<br>    FTransform Transform &#x3D; GetActorTransform();<br>    FVector Location &#x3D; Transform.GetLocation();<br>    FRotator Rotator &#x3D; Transform.Rotator();<br>    FVector Scale &#x3D; Transform.GetScale3D();</p>
<p><code>SpawnActor()</code>先调用<code>BaseGeometryActor</code>类的构造函数，然后立即调用<code>BeginPlay()</code>,因此我们在生成Actor后调用<code>SetData()</code>设置数据发生在Actor生成完成，此时<code>BeginPlay()</code>已经调用完成，因此生成Actor时的数据都是我们在构造函数和<code>BeginPlay()</code>中初始化的数据。也就是说<code>SetData()</code>并不能有效提供初始化类所需要的数据。<br>因此我们需要一种方法延迟调用<code>BeginPlay()</code>，即使用<code>SpawnActorDeferred()</code>替代<code>SpawinActor()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用该函数创建对象时仅会调用构造函数而不会调用BeginPlay(),因此我们可以手动配置Actor的参数</span></span><br><span class="line"><span class="comment">//但需要我们手动调用BeginPlay()</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//生成Actor的坐标</span></span><br><span class="line">			<span class="type">const</span> FTransform BaseGeometryActorTransform = <span class="built_in">FTransform</span>(<span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">300.0f</span>*i, <span class="number">300.0f</span>));</span><br><span class="line">			<span class="comment">//使用World调用SpawnActor方法生成Actor，该方法返回所指定的Actor指针，没有指定就返回AActor*</span></span><br><span class="line">			ABaseGeometryActor* BaseGeometryActor = World-&gt;<span class="built_in">SpawnActorDeferred</span>&lt;ABaseGeometryActor&gt;(GeometryClass, BaseGeometryActorTransform);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (BaseGeometryActor)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//配表！</span></span><br><span class="line">                <span class="comment">//注意，如果使用的是SpawnActor()而不是SpawnActorDeferred()，下面的赋值是在Actor创建后进行赋值，因此在BeginPlay()时，各项数据还都是初始值！</span></span><br><span class="line">				FBaseGeometryActorData BaseGeometryActorData;</span><br><span class="line">				BaseGeometryActorData.InitLocation = BaseGeometryActorTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">				BaseGeometryActorData.MovementType = FMath::<span class="built_in">RandBool</span>() ? EMovementType::SimpleHarmonicMotion : EMovementType::Static;</span><br><span class="line">				BaseGeometryActorData.Amplitude = <span class="number">150.0f</span>;</span><br><span class="line">				BaseGeometryActorData.Frequency = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">				BaseGeometryActorData.bChangeColorRandomly = <span class="literal">true</span>;</span><br><span class="line">				BaseGeometryActorData.TimerCountMax = <span class="number">10</span>;</span><br><span class="line">				BaseGeometryActorData.TimerRate = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">				BaseGeometryActor-&gt;<span class="built_in">SetData</span>(BaseGeometryActorData);</span><br><span class="line">				<span class="comment">//调用Actor的FinishSpawning()来完成BeginPlay()的手动调用</span></span><br><span class="line">				BaseGeometryActor-&gt;<span class="built_in">FinishSpawning</span>(BaseGeometryActorTransform); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="更方便地生成自定义Actor"><a href="#更方便地生成自定义Actor" class="headerlink" title="更方便地生成自定义Actor"></a>更方便地生成自定义Actor</h2><p>在Actor类对应的Hub类中封装Acotr需要的数据以更方便地实现生成自定义Actor</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Actor类对应的Hub类中封装Acotr需要的数据以更方便地实现生成自定义Actor，</span></span><br><span class="line"><span class="comment">//该结构体需要包含三个字段：我们要生成的类、类的数据的字段、负责Transform的字段</span></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FBaseGeometryActorPayload</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_USTRUCT_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	TSubclassOf&lt;ABaseGeometryActor&gt; GeometryClass; <span class="comment">//起到过滤作用，在编辑面板中将只显示所选的类及其子类(包括蓝图类)，即该指针只能指向所选的类及其子类</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	FBaseGeometryActorData BaseGeometryActorData;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">	FTransform InitTransform;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in cpp file</span></span><br><span class="line">		<span class="keyword">for</span> (FBaseGeometryActorPayload Payload : BaseGeometryActorPayloads)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (World)</span><br><span class="line">			&#123;</span><br><span class="line">				ABaseGeometryActor* BaseGeometryActor = World-&gt;<span class="built_in">SpawnActorDeferred</span>&lt;ABaseGeometryActor&gt;(Payload.GeometryClass, Payload.InitTransform);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (BaseGeometryActor)</span><br><span class="line">				&#123;</span><br><span class="line">					BaseGeometryActor-&gt;<span class="built_in">SetData</span>(Payload.BaseGeometryActorData);</span><br><span class="line">					BaseGeometryActor-&gt;<span class="built_in">FinishSpawning</span>(Payload.InitTransform);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>what to do： 嵌套循环生成一排Actor、对所有指针进行检查</p>
<h1 id="UEh中的委托"><a href="#UEh中的委托" class="headerlink" title="UEh中的委托"></a>UEh中的委托</h1><p>BaseGeometryActor发送事件、Hub类订阅事件</p>
<p>什么是委托<br>Delegates allows you to store a reference to a method with a specific signature of an arbitrary class and call this method when necessary.</p>
<blockquote>
<p>我们习惯于把数据作为参数传递给方法，所以，给方法传递另一个方法听起来有点奇怪。而有时某个方法执行的操作并不是针对数据进行的，而是要对另一个方法进行操作。更麻烦的是，在编译时我们不知道第二个方法是什么，这个信息只能在运行时得到，所以需要把第二个方法作为参数传递给第一个方法。<br>在C和C++中，只能提取函数的地址，并作为一个参数传递它。C没有类型安全性，可以把任何函数传递给需要函数指针的方法。但是，这种直接方法不仅会导致一些关于类型安全性的问题，而且没有意识到：在进行面向对象编程时，几乎没有方法是孤立存在的，而是在调用方法前通常需要与类实例相关联。所以.NET Framework在&gt;语法上不允许使用这种直接方法。如果要传递方法，就必须把方法的细节封装在一种新类型的对象中，即委托。委托只是一种特殊类型的对象，其特殊之处在于，我们&gt;以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。<br>立存在的，而是在调用方法前通常需要与类实例相关联。所以.NET Framework在语法上不允许使用这种直接方法。如果要传递方法，就必须把方法的细节封装在一种新类型的对象中，即委托。委托只是一种特殊类型的对象，其特殊之处在于，我们以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。<br>【CSDN:<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67296957/article/details/131844269%E3%80%91">https://blog.csdn.net/m0_67296957/article/details/131844269】</a></p>
</blockquote>
<p>委托即一种更安全的函数指针<br>关于UE中委托的详细教程见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/419232568?utm_id=0">https://zhuanlan.zhihu.com/p/419232568?utm_id=0</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Declares a delegate that can only bind to one native function at a time */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DELEGATE( DelegateName ) FUNC_DECLARE_DELEGATE( DelegateName, void )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Declares a broadcast delegate that can bind to multiple native functions simultaneously */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_MULTICAST_DELEGATE( DelegateName ) FUNC_DECLARE_MULTICAST_DELEGATE( DelegateName, void )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Declares a blueprint-accessible delegate that can only bind to one UFUNCTION at a time */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DYNAMIC_DELEGATE( DelegateName ) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_DELEGATE) FUNC_DECLARE_DYNAMIC_DELEGATE( FWeakObjectPtr, DelegateName, DelegateName##_DelegateWrapper, , FUNC_CONCAT( *this ), void )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Declares a blueprint-accessible broadcast delegate that can bind to multiple native UFUNCTIONs simultaneously */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DYNAMIC_MULTICAST_DELEGATE( DelegateName ) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_DELEGATE) FUNC_DECLARE_DYNAMIC_MULTICAST_DELEGATE( FWeakObjectPtr, DelegateName, DelegateName##_DelegateWrapper, , FUNC_CONCAT( *this ), void )</span></span><br></pre></td></tr></table></figure>
<p>UE中的委托最多有9个参数</p>
<p>以动态多播委托为例(动态委托可在蓝图中绑定函数)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用宏声明委托</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams</span>(FOnColorChanged, <span class="type">const</span> FLinearColor&amp;, Color, <span class="type">const</span> FString&amp;, Name);</span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FOnTimerFinished, AActor*);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建委托实例</span></span><br><span class="line">FOnColorChanged OnColorChanged;</span><br><span class="line">FOnTimerFinished OnTimerFinished;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.触发(广播)委托</span></span><br><span class="line">FOnColorChanged.<span class="built_in">Broadcast</span>(RandomColor, <span class="built_in">Getname</span>());</span><br><span class="line">FOnTimerFinished.<span class="built_in">Broadcast</span>(<span class="keyword">this</span>);  </span><br><span class="line"><span class="comment">//传递AActor子类指针时，该指针会自动向上转换(up-cast)为指向AActor的指针</span></span><br><span class="line"><span class="comment">//也可以进行手动转换: ABaseGeometryAcotr* BaseGeometryAcotr = Cast&lt;ABaseGeometryAcotr&gt;(Actor);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定函数(一般在另一个类中,此处在AGeometryHubActor类中)</span></span><br><span class="line"><span class="comment">//绑定的函数签名必须与委托一致；绑定函数到动态委托，该函数必须是UFUNCTION,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGeometryHubActor::OnColorChanged</span><span class="params">(<span class="type">const</span> FLinearColor&amp; Color, <span class="type">const</span> FString&amp; Name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogGeometryHub, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Actor name:%s ,Color:%s&quot;</span>), *Name, *Color.<span class="built_in">ToString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGeometryHubActor::OnTimerFinished</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Actor)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogGeometryHub, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Timer Finished: %s&quot;</span>), *Actor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseGeometryActor为广播委托所在的类的指针; </span></span><br><span class="line">BaseGeometryActor-&gt;OnColorChanged.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AGeometryHubActor::OnColorChanged);</span><br><span class="line">BaseGeometryActor-&gt;OnTimerFinished.<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AGeometryHubActor::OnTimerFinished);</span><br></pre></td></tr></table></figure>

<h2 id="Actor的销毁"><a href="#Actor的销毁" class="headerlink" title="Actor的销毁"></a>Actor的销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGeometryHubActor::OnTimerFinished</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Actor)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogGeometryHub, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Timer Finished: %s&quot;</span>), *Actor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">	<span class="comment">//在计时器结束时，销毁创建的Actor</span></span><br><span class="line">	BaseGeometryActor-&gt;<span class="built_in">Destory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~cpp</span><br><span class="line"><span class="comment">//这种方法可启动一个计时器，指定多长时间后销毁Actor,</span></span><br><span class="line">BaseGeometryActor-&gt;<span class="built_in">SetLifeSpan</span>(<span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure>

<h2 id="重写BaseGeometryActor的EndPlay"><a href="#重写BaseGeometryActor的EndPlay" class="headerlink" title="重写BaseGeometryActor的EndPlay()"></a>重写BaseGeometryActor的EndPlay()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EgineType.h中定义了五种EndPlayReason</span></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">namespace</span> EEndPlayReason</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/** When the Actor or Component is explicitly destroyed. */</span></span><br><span class="line">		Destroyed,</span><br><span class="line">		<span class="comment">/** When the world is being unloaded for a level transition. */</span></span><br><span class="line">		LevelTransition,</span><br><span class="line">		<span class="comment">/** When the world is being unloaded because PIE is ending. */</span></span><br><span class="line">		EndPlayInEditor,</span><br><span class="line">		<span class="comment">/** When the level it is a member of is streamed out. */</span></span><br><span class="line">		RemovedFromWorld,</span><br><span class="line">		<span class="comment">/** When the application is being exited. */</span></span><br><span class="line">		Quit,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in cpp file, 当Actor销毁时打印消息; 要使用Super调用父类的EndPlay()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ABaseGeometryActor::EndPlay</span><span class="params">(<span class="type">const</span> EEndPlayReason::Type EndPlayReason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">EndPlay</span>(EndPlayReason);</span><br><span class="line">	<span class="built_in">UE_LOG</span>(LogBaseGeometry, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Actor is dead: %s&quot;</span>), *<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="APawn类与键盘输入"><a href="#APawn类与键盘输入" class="headerlink" title="APawn类与键盘输入"></a>APawn类与键盘输入</h1><p>GameMode中的设置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ASandboxPawn::StaticClass()获取UClass类型指针赋给DefaultPawnClass</span></span><br><span class="line">DefaultPawnClass = ASandboxPawn::<span class="built_in">StaticClass</span>();</span><br></pre></td></tr></table></figure>
<h2 id="让Pawn移动"><a href="#让Pawn移动" class="headerlink" title="让Pawn移动"></a>让Pawn移动</h2><p>首先在项目设置里绑定映射</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册委托的两个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::MoveForward</span><span class="params">(<span class="type">float</span> Scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Velocity.X = Speed * Scale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::MoveRight</span><span class="params">(<span class="type">float</span> Scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Velocity.Y = Speed * Scale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册委托</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line">	PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>), <span class="keyword">this</span>, &amp;ASandboxPawn::MoveForward);</span><br><span class="line">	PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveRight&quot;</span>), <span class="keyword">this</span>, &amp;ASandboxPawn::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轴映射输入要借助Tick实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Velocity.<span class="built_in">IsZero</span>()) <span class="comment">//当速度为0时不必计算，提高性能</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogSandboxPawn, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Test_2&quot;</span>));</span><br><span class="line">		<span class="type">const</span> FVector NewLocation = <span class="built_in">GetActorLocation</span>() + Velocity * DeltaTime;</span><br><span class="line">		<span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="APlayerController类"><a href="#APlayerController类" class="headerlink" title="APlayerController类"></a>APlayerController类</h1><p>补充:关于C++的前置声明<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/578829138?utm_id=0">https://zhuanlan.zhihu.com/p/578829138?utm_id=0</a><br>如果两个头文件都有文件包含保护，编译A时会把B包含进来，但因为B包含了A，A中的包含保护生效，导致B文件内的内容实际未引入A，于是报B为未知符号的错误。</p>
<p>创建GameMode的蓝图子类，即可在蓝图中设置其管理的各个类；在WorldSetting中将该蓝图类设置为GameMode，就可以实现在WorldSetting中直接设置该蓝图类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建SandboxController类继承自APlayController</span></span><br><span class="line"><span class="comment">//重写父类的SetupInputComponent()，自定义自己的InputComponent，并把函数注册到委托</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPlayerController::SetupInputComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupInputComponent</span>();</span><br><span class="line">	<span class="keyword">if</span> (InputComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ChangePawn&quot;</span>), EInputEvent::IE_Pressed, <span class="keyword">this</span>, &amp;ASandboxPlayerController::ChangePawn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in .cpp file 准备实现ChangePawn()</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;AActor*&gt; Pawns; <span class="comment">//需要加宏，且类型为AActor</span></span><br><span class="line"></span><br><span class="line">	int32 CurrentPawnIndex;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChangePawn</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先获取场上的Actor，储存在Pawn中</span></span><br><span class="line"><span class="comment">//加入头文件 &quot;Kismet/GameplayStatics.h&quot;</span></span><br><span class="line"><span class="comment">//void UGameplayStatics::GetAllActorsOfClass(const UObject* WorldContextObject, TSubclassOf&lt;AActor&gt; ActorClass, TArray&lt;AActor*&gt;&amp; OutActors)</span></span><br><span class="line">UGameplay::<span class="built_in">GetAllActorsOfClass</span>(<span class="built_in">GetWorld</span>(), ASandboxPawn::<span class="built_in">StaticClass</span>(), Pawns);</span><br><span class="line"><span class="comment">//实现ChangePawn()</span></span><br><span class="line">ASandboxPlayerController::<span class="built_in">ChangePawn</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Q：为什么Pawns[0]不是当前控制的Pawn？因为当前控制的Pawn一定是游戏开始时GameMode生成的Pawn，而(不知道为什么)这个实例的指针是Pawn中的最后一个成员</span></span><br><span class="line">	<span class="comment">//需要先将获得的Pawns类型转换成Pawn类型，再通过Possess获得其控制权</span></span><br><span class="line">	<span class="keyword">if</span>(Pawn.<span class="built_in">Num</span>()&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        ASandboxPawn* CurrentPawn = <span class="built_in">Cast</span>&lt;ASandboxPawn&gt;(Pawn[CurrentPawnIndex]);</span><br><span class="line">		<span class="keyword">if</span>(CurrentPawn)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//void AController::Possess(APawn* InPawn)</span></span><br><span class="line">			<span class="built_in">Possess</span>(CurrentPawn);</span><br><span class="line">			<span class="comment">//实现循环改变Pawn，即Pawn改变一轮后，重新从头开始。下面这个算法比较节约性能</span></span><br><span class="line">			CurrentPawnIndex = ( CurrentPawnIndex + <span class="number">1</span> ) % Pawn.<span class="built_in">Num</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>补充：APawn中的InputComponent与APlayerController中的InPutComponent<br>一般在APawn中实现该Pawn的功能，这些功能是发生在该Pawn上的。而在APlayerController中实现对很多Pawn进行控制的功能</p>
<p>当不需要AIController时，在BP_Pawn的Auto Possess AI中设置相关选项<br>[图片]<br>如果在移动中切换Pawn，则该Pawn会继续移动下去。因为在Unpossess后，void ASandboxPawn::UnPossessed()中Destroy了Actor的PlayInputComponent,BindAxis()函数将失效，也就是说Trik()中Velocity的值将不会再改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该绑定失效，因为PlayInputComponent已被删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line">	PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveForward&quot;</span>), <span class="keyword">this</span>, &amp;ASandboxPawn::MoveForward);</span><br><span class="line">	PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MoveRight&quot;</span>), <span class="keyword">this</span>, &amp;ASandboxPawn::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Scale的值不会发生改变，Velocity将始终保持释放时的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::MoveForward</span><span class="params">(<span class="type">float</span> Scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Velocity.X = Speed * Scale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::MoveRight</span><span class="params">(<span class="type">float</span> Scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Velocity.Y = Speed * Scale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Tick()中的位移于是一直在进行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASandboxPawn::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!Velocity.<span class="built_in">IsZero</span>()) <span class="comment">//当速度为0时不必计算，提高性能</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FVector NewLocation = <span class="built_in">GetActorLocation</span>() + Velocity * DeltaTime;</span><br><span class="line">		<span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修正方法1：可以在位移时检测该Pawn是否被控制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsControlled</span>() &amp;&amp; !Velocity.<span class="built_in">IsZero</span>() ) <span class="comment">//当速度为0时不必计算，提高性能</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FVector NewLocation = <span class="built_in">GetActorLocation</span>() + Velocity * DeltaTime;</span><br><span class="line">		<span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//修正方法2(不可行！)：在UnPossess()中重置Velocity————不可行！</span></span><br><span class="line"><span class="comment">//修正方法3：在Tick()中在每次位移完重置Velocity</span></span><br></pre></td></tr></table></figure>

<h1 id="Module-Target-UBT-Garbage-Collector"><a href="#Module-Target-UBT-Garbage-Collector" class="headerlink" title="Module, Target, UBT, Garbage Collector"></a>Module, Target, UBT, Garbage Collector</h1><h2 id="BT"><a href="#BT" class="headerlink" title="BT"></a>BT</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in file FPSLearning.Build.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FPSLearning</span> : <span class="title">ModuleRules</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FPSLearning</span>(<span class="params">ReadOnlyTargetRules Target</span>) : <span class="title">base</span>(<span class="params">Target</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*为什么UCameraComponent需要前置声明，而UStaticMeshComponent则不需要？因为头文件&#x27;StaticMeshComponent.h&#x27;包含在Actor.h中</span></span><br><span class="line"><span class="comment">        实际上我们可以删除绝大多数的头文件，并在VS中右键项目点击build，项目也会成功构建</span></span><br><span class="line"><span class="comment">        这是因为使&#x27;precompiled headers&#x27;这一功能，FPSLearning.Build.cs有一个PCHUsage的字段实现了这一功能</span></span><br><span class="line"><span class="comment">        Engine/Public/EngineSharedPCH.h中包含了绝大多数头文件，在构建项目时会隐式地添加该文件*/</span></span><br><span class="line">		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">//模块化编译，游戏也是其中的一个文件()</span></span><br><span class="line">		<span class="comment">//添加本项目所需的四个模块</span></span><br><span class="line">		PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Core&quot;</span>, <span class="string">&quot;CoreUObject&quot;</span>, <span class="string">&quot;Engine&quot;</span>, <span class="string">&quot;InputCore&quot;</span> &#125;); </span><br><span class="line"></span><br><span class="line">		PrivateDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="built_in">string</span>[] &#123;  &#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Uncomment if you are using Slate UI</span></span><br><span class="line">		<span class="comment">// PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Slate&quot;, &quot;SlateCore&quot; &#125;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Uncomment if you are using online features</span></span><br><span class="line">		<span class="comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h2><p>在调用<code>Destory()</code>之后，不会立即删除内存中的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UE_LOG</span>(LogGeometryHub, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;NoneProperty pointer %i, is valid %i&quot;</span>), NonePropertyActor != <span class="literal">nullptr</span>, <span class="built_in">IsValid</span>(NonePropertyActor));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogGeometryHub, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Property pointer %i, is valid %i&quot;</span>), PropertyActor != <span class="literal">nullptr</span>, <span class="built_in">IsValid</span>(PropertyActor));</span><br></pre></td></tr></table></figure>
<p><code>Destory()</code>设置了<code>PengdingToKill = true</code>，不管该指针是否被宏标记，<code>IsValid()</code>判断都为<code>Flase</code>，而指针都为<code>True</code>，即打印:</p>
<p>NoneProperty pointer 1, is valid 0<br>Property pointer 1, is valid 0</p>
<p>然后强制调用UE的垃圾回收函数，此时被宏标记的对象被回收，这是正确的。而未被宏标记的指针将指向一个空的内存，成为Dangling Pointer，这是十分危险的。此时将打印：</p>
<p>NoneProperty pointer 1, is valid 1<br>Property pointer 0, is valid 0</p>
<h1 id="创建项目，添加内容"><a href="#创建项目，添加内容" class="headerlink" title="创建项目，添加内容"></a>创建项目，添加内容</h1><p>增加版权<br>Edit → ProjectSetting<br><img src="/pics/%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9D%83.png" alt="增加版权"><br>此描述将显示在每个源码文件的顶部</p>
<p>设置编辑器打开时默认加载的关卡<br><img src="/pics/%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%BE%91%E5%99%A8%E9%BB%98%E8%AE%A4%E5%85%B3%E5%8D%A1%E5%92%8C%E6%B8%B8%E6%88%8F%E9%BB%98%E8%AE%A4%E5%85%B3%E5%8D%A1.png" alt="设置编辑器默认关卡和游戏默认关卡"></p>
<h1 id="编码标准"><a href="#编码标准" class="headerlink" title="编码标准"></a>编码标准</h1><p>使用ClangFormat控制格式，ClangFormat是YAML标记语言<br>在项目文件创建<code>.clang-format</code>文件，重新生成项目文件，在VS打开新建的<code>.clang-format</code>文件<br>然后再vs中启用工具：<code>Tools → Options → Text Editor → C/C++ → Formatting → Enable ClangFormat support</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Language: Cpp</span><br><span class="line">#BasedOnStyle: Microsoft</span><br><span class="line">IndentWidth: <span class="string">&#x27;4&#x27;</span></span><br><span class="line">UseTab: Never</span><br><span class="line">TabWidth: <span class="string">&#x27;4&#x27;</span></span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">ColumnLimit: <span class="string">&#x27;140&#x27;</span></span><br><span class="line">AccessModifierOffset: <span class="string">&#x27;-4&#x27;</span></span><br><span class="line">SortIncludes: <span class="literal">false</span></span><br><span class="line">AllowShortBlocksOnASingleLine: <span class="literal">false</span></span><br><span class="line">AlignAfterOpenBracket: DontAlign</span><br><span class="line">AllowShortFunctionsOnASingleLine: Inline</span><br><span class="line">PointerAlignment: Left</span><br></pre></td></tr></table></figure>

<p>补充<br>VS中，Ctrl K + Ctrl D 重置格式</p>
<p>其次，添加.gitignore</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.vs/</span><br><span class="line">Binaries/</span><br><span class="line">Build/</span><br><span class="line">DerivedDataCache/</span><br><span class="line">Intermediate/</span><br><span class="line">saved/</span><br><span class="line">*.sln</span><br></pre></td></tr></table></figure>

<h1 id="创建ACharactor和APlayerController"><a href="#创建ACharactor和APlayerController" class="headerlink" title="创建ACharactor和APlayerController"></a>创建ACharactor和APlayerController</h1><p>在C++Classes下新建文件夹Play创建类<code>STUBaseCharactor</code>，此时必须包含这个类的头文件必须使用 <code>#include &quot;Player/STUBaseCharacter.h&quot;</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in xxx.Build.cs</span></span><br><span class="line">PublicIncludePaths.AddRange(<span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;FPSProject/Pubilc/Player&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>创建好STUBaseCharator和STUPlayerController后，将GameModeBase中的默认Pawn和PlayController换成我们新创建的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUGameModeBase.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STUGameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Player/STUBaseCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Player/STUPlayerController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ASTUGameModeBase::<span class="built_in">ASTUGameModeBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DefaultPawnClass = ASTUBaseCharacter::<span class="built_in">StaticClass</span>();</span><br><span class="line">    PlayerControllerClass = ASTUPlayerController::<span class="built_in">StaticClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建STUGameModeBase、STUBaseCharator和STUPlayerController对应的蓝图类，BP_STUGameModeBase、BP_STUBaseCharator和BP_STUPlayerController，<br>用BP子类复写游戏模式，并将对应的Pawn和PlayerController换成BP子类的<br><img src="/pics/%E7%94%A8%E8%93%9D%E5%9B%BE%E5%AD%90%E7%B1%BB%E6%9B%BF%E6%8D%A2.png" alt="用蓝图子类替换"></p>
<p>为Character创建相机组件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建组件步骤：1声明指针  2.创建子物体  3.附着到根组件上</span></span><br><span class="line">ASTUBaseCharacter::<span class="built_in">ASTUBaseCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	CameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="string">&quot;CameraComponent&quot;</span>);</span><br><span class="line">	CameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基本角色移动"><a href="#基本角色移动" class="headerlink" title="基本角色移动"></a>基本角色移动</h1><p>既可以在Controller中，也可以在Character中控制角色的移动，下面使用与前面不同的另一种方式实现移动，使用AddMovementInput()实现移动，该函数是对AddVectorInput()这一属性的封装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//in STUBaseCharacter.cpp</span></span><br><span class="line"><span class="comment">//需要包含头文件 &quot;Components/InputComponent.h&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line">	PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::MoveForward);</span><br><span class="line">	PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::MoveForward</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">AddMovementInput</span>(<span class="built_in">GetActorForwardVector</span>(), ScaleValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::MoveRight</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">AddMovementInput</span>(<span class="built_in">GetActorRightVector</span>(), ScaleValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="角色相机控制"><a href="#角色相机控制" class="headerlink" title="角色相机控制"></a>角色相机控制</h1><p>实现转动鼠标控制视角，使用AddControllerPitchInput()和AddControllerYawInput()，该函数是对AddPitchInput()和AddYawInput()的封装，在AddPitchInput()和AddYawInput()中，将改变RotationInput这一结构体属性的Pitch值和Yaw值，这两个函数和该属性都是PlayController的成员。我们通过改变Controller的旋转来实现Pawn的旋转，而上面的移动控制中的函数是Pawn自身的。<br><img src="/pics/%E6%97%8B%E8%BD%AC%E7%94%B1Controller%E6%8E%A7%E5%88%B6.png" alt="旋转由Controller控制"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUBaseCharacter.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::LookUp</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">AddControllerPitchInput</span>(ScaleValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::LookAround</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">AddControllerYawInput</span>(ScaleValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面利用SpringArmComponent实现让摄像机绕角色转动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUBaseCharacter.cpp</span></span><br><span class="line"><span class="comment">//包含头文件&quot;GameFramework/SpringArmComponent.h&quot;</span></span><br><span class="line">SpringArmComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="string">&quot;SpringArmComponent&quot;</span>);</span><br><span class="line">SpringArmComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line">SpringArmComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">CameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="string">&quot;CameraComponent&quot;</span>);</span><br><span class="line"><span class="comment">//将CameraComponent的父级更改为SpringArmComponent</span></span><br><span class="line">CameraComponent-&gt;<span class="built_in">SetupAttachment</span>(SpringArmComponent);</span><br></pre></td></tr></table></figure>

<p>最后，因为AddMovementInput()、AddControllerPitchInput()具有相同的函数签名，且都接收一个float变量。因此，在绑定按键时，直接将这些函数注册到委托，而无需自己再创建新的函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Lookup&quot;</span>, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::AddControllerPitchInput);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookAround&quot;</span>, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::AddControllerYawInput);</span><br></pre></td></tr></table></figure>

<h1 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h1><p>实现Idle动画和Run_Fwd动画的混合</p>
<p>创建动画蓝图方式1：骨骼网络资产 → Create → AnimBlueprint<br>创建动画蓝图方式2：在文件夹中直接右键 → Animation → AnimationBlueprint</p>
<p>创建BlendSpace1D并实现动画的混合<br>然后在动画蓝图中实现动画<br><img src="/pics/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE1.png" alt="在动画蓝图中实现动画"><br><img src="/pics/%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE2.png" alt="在动画蓝图中实现动画"></p>
<h1 id="跳跃动画，状态机-State-Mechines"><a href="#跳跃动画，状态机-State-Mechines" class="headerlink" title="跳跃动画，状态机(State Mechines)"></a>跳跃动画，状态机(State Mechines)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUBaseCharacter.cpp</span></span><br><span class="line"><span class="comment">//绑定跳跃，jump已在ACharacter类中被封装好</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::Jump);</span><br></pre></td></tr></table></figure>

<p>检测角色是否处于下坠状态<br>![检测是否下坠](pics&#x2F;跳跃动画，状态机(State Mechine)1.png)</p>
<p>使用StateMechine实现动画流，StateMechine可以管理动画蓝图中的多个动画并自定义动画之间的过渡<br>![使用StateMechine实现动画流](pics&#x2F;跳跃动画，状态机(State Mechine)2.png)</p>
<p>将JumpStart和JumpEnd的LoopAnimation设置为False</p>
<p>#跑步动画<br>实现按Left Shift可从步行切换至跑步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">角色只有满足下面三个条件，才能处于跑步状态：①正在向前移动；②接收到shift切换跑步的输入；③角色的速度不为<span class="number">0</span>。 检测速度的目的是避免角色卡在某处或其他原因导致角色的速度降为<span class="number">0</span></span><br><span class="line"><span class="comment">//1.绑定切换跑步所用的函数，用一个布尔变量bWantToRun反映玩家的输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::OnStartRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bWantToRun = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::OnStopRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bWantToRun = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Run&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::OnStartRunning);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Run&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;ASTUBaseCharacter::OnStopRunning);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断角色是否在向前移动，只有角色在向前移动时才可以切换跑步状态。一般情况下可以用角色的速度和角色朝向的夹角判断，因为我们目前只有一个向前运动的动画，所以只有MoveForward()时才会向前运动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::MoveForward</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bIsMovingForward = ScaleValue &gt; <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">AddMovementInput</span>(<span class="built_in">GetActorForwardVector</span>(), ScaleValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.定义供动画蓝图调用的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ASTUBaseCharacter::IsRunning</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">GetVelocity</span>().<span class="built_in">IsZero</span>() &amp;&amp; bIsMovingForward &amp;&amp; bWantToRun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.实现在跑步状态时速度增加 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//in STUCharacterMovementComponent.cpp</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">USTUCharacterMovementComponent::GetMaxSpeed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">float</span> MaxSpeed = Super::<span class="built_in">GetMaxSpeed</span>();</span><br><span class="line">	<span class="comment">//GetPawnOwner()获得该MovementComponent所有者的指针(Pawn类型)</span></span><br><span class="line">	<span class="type">const</span> ASTUBaseCharacter* Player = <span class="built_in">Cast</span>&lt;ASTUBaseCharacter&gt;(<span class="built_in">GetPawnOwner</span>());</span><br><span class="line">	<span class="keyword">if</span> (Player &amp;&amp; Player-&gt;<span class="built_in">IsRunning</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> MaxSpeed * RunModifier;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> MaxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in STUBaseCharacter.cpp </span></span><br><span class="line"><span class="comment">//覆盖父类Character原有的CharacterMovementComponent组件，因为必须在父类初始化前完成，所以通过C++构造函数传递FObjectInitializer类型变量来实现。</span></span><br><span class="line"><span class="comment">//这里是实现了用自定义的CharacterMovementComponent替换了父类原有的组件</span></span><br><span class="line">ASTUBaseCharacter::<span class="built_in">ASTUBaseCharacter</span>(<span class="type">const</span> FObjectInitializer&amp; ObjInit)</span><br><span class="line">	: <span class="built_in">Super</span>(ObjInit.<span class="built_in">SetDefaultSubobjectClass</span>&lt;USTUCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName))</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以直接调用父类的CharacterMovement设置MaxWalkSpeed。</span></span><br><span class="line"><span class="comment">//需要包含头文件 &quot;GameFramework/CharacterMovementComponent.h&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::OnStartRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bWantToRun = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::OnStopRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bWantToRun = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">1200.f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="前后左右的运动动画"><a href="#前后左右的运动动画" class="headerlink" title="前后左右的运动动画"></a>前后左右的运动动画</h1><p>用2D混合空间实现走-跑切换和方向切换同时进行，水平轴是速度，垂直轴是方向(-180° ~ 180°)</p>
<p>绘制射线<br>(蓝图节点：GetActorForwardVector：获得当前角色朝向的单位向量)<br><img src="/pics/%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%9A%84%E8%BF%90%E5%8A%A8%E5%8A%A8%E7%94%BB1.png" alt="在蓝图中绘制射线"><br><img src="/pics/%E5%89%8D%E5%90%8E%E5%B7%A6%E5%8F%B3%E7%9A%84%E8%BF%90%E5%8A%A8%E5%8A%A8%E7%94%BB2.png" alt="在蓝图中绘制射线"><br>然后在ProjectSetting → Rendering中关闭自动曝光(?可能影响视觉效果)</p>
<p>用C++实现代替蓝图实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ASTUBaseCharacter::GetMovementDirction</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FVector VectorNormal = <span class="built_in">GetVelocity</span>().<span class="built_in">GetSafeNormal</span>();</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> AngleBetween = FMath::<span class="built_in">Acos</span>(FVector::<span class="built_in">DotProduct</span>(<span class="built_in">GetActorForwardVector</span>(), VectorNormal));</span><br><span class="line">	<span class="type">const</span> FVector CrossProduct = FVector::<span class="built_in">CrossProduct</span>(<span class="built_in">GetActorForwardVector</span>(), VectorNormal);</span><br><span class="line">	<span class="keyword">return</span> FMath::<span class="built_in">Sign</span>(CrossProduct.Z)* FMath::<span class="built_in">RadiansToDegrees</span>(AngleBetween);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后实现：只有在向前奔跑时才能加速，一旦按下左右移动键，就不能奔跑。即实现下面两个功能：<br>1.进入跑步状态后如果一直按住Shift不放，其他动作仍保持加速，因为OnStopRunning()没有调用，MaxWalkSpeed没有被还原。在跑步时一旦有左右移动输入，就需要将速度还原。<br>2.跑步动画是1D混合空间，所以跑步时不能左右移动。必须在获得左右移动输入后切换为行走动画。增加bIsMovingRight在IsRunning中进行判断可解决。</p>
<p>顺序上，显然先实现2，再实现1；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新声明成员bool bIsMovingRight；当有左右向输入时，bIsMovingForward = false；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::MoveForward</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//该判断需要放if外面；</span></span><br><span class="line">	bIsMovingForward = ScaleValue &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ScaleValue != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AddMovementInput</span>(<span class="built_in">GetActorForwardVector</span>(), ScaleValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后再将速度还原，最好不要在Tick中通过检测IsRunning()实现，耗费性能。应当考虑各种情况分别处理。目前，只有在“奔跑时进行了左右移动的输入”这一种情况需要处理。可以直接在MovingRight()中处理。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::MoveRight</span><span class="params">(<span class="type">float</span> ScaleValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//该判断需要放if外面；</span></span><br><span class="line">	bIsMovingRight = (ScaleValue != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ScaleValue != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当跑步时有左右移动输入，将速度还原</span></span><br><span class="line">		<span class="comment">//此处不能判断if(IsRunning())，因为上一条语句已经设置了bIsMovingRight的值，改变了IsRunning()的返回值</span></span><br><span class="line">		<span class="keyword">if</span> (bWantToRun &amp;&amp; bIsMovingForward)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">AddMovementInput</span>(<span class="built_in">GetActorRightVector</span>(), ScaleValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OnStopRunning()也可以加个	if (IsRunning())的判断</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::OnStopRunning</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//先设置bWantToRun = false，再还原最大速度</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsRunning</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bWantToRun = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 重构奔跑代码：</span><br><span class="line">·一开始按住Shift时加速对所有动作有效</span><br><span class="line">·按住shift从非奔跑动画切换到奔跑动画，不会加速</span><br><span class="line"></span><br><span class="line">综合来看，要在<span class="built_in">MoveForward</span>()中修改MaxWalkSpeed = <span class="number">1200.f</span>，在<span class="built_in">MoveRight</span>()中修改MaxWalkSpeed = <span class="number">600.f</span>，同时为保证速度能得到及时的还原，在<span class="built_in">OnStopRunning</span>()也需要再还原一下速度；</span><br><span class="line">在调整最大速度后，考虑所有需要还原速度的场景：(注意不要直接判断速度，因为可能有其他的运动场景)</span><br><span class="line"><span class="number">1.</span>玩家松开Shift；</span><br><span class="line"><span class="number">2.</span>玩家没松开Shift，但不在笔直向前了(有左右移动的输入 || 笔直向后)</span><br><span class="line">~~~cpp</span><br><span class="line"><span class="comment">//设置最大速度</span></span><br><span class="line">	<span class="comment">//in MoveForward()</span></span><br><span class="line">	<span class="keyword">if</span> (bWantToRun &amp;&amp; bIsMovingForward &amp;&amp; !bIsMovingRight)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">1200.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原最大速度</span></span><br><span class="line">	<span class="comment">//in MoveForward() 笔直向后、原地静止的情况</span></span><br><span class="line">	<span class="keyword">if</span> (bWantToRun &amp;&amp; bIsMovingForward &amp;&amp; !bIsMovingRight)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">1200.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bIsMovingForward &amp;&amp; (<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed == <span class="number">1200.f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//in MoveRight() 有左右移动输入的情况</span></span><br><span class="line">	bIsMovingRight = (ScaleValue != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (bIsMovingRight)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed == <span class="number">1200.f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">AddMovementInput</span>(<span class="built_in">GetActorRightVector</span>(), ScaleValue);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在OnStopRunning()也需要再还原一下速度，避免各种其他意想不到的情况</span></span><br><span class="line">	<span class="keyword">if</span> (!(<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed == <span class="number">1200.f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">GetCharacterMovement</span>()-&gt;MaxWalkSpeed = <span class="number">600.f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bWantToRun = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>




<h1 id="健康管理"><a href="#健康管理" class="headerlink" title="健康管理"></a>健康管理</h1><p>创建STUHealthComponent类，并在角色中添加该组件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUHealthComponent.h</span></span><br><span class="line">	<span class="comment">//设置bCanEverTick = false，删除TickComponent()</span></span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetHealth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Health; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadWrite)</span><br><span class="line">	flat MaxHealth;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> Health;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in STUBaseCharacter.cpp</span></span><br><span class="line">	<span class="comment">//HealthComponent是纯逻辑的，没有场景组件，不需要调用SetupAttachment()</span></span><br><span class="line">	HealthComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USTUHealthComponent&gt;(<span class="string">&quot;HealthCompnent&quot;</span>);</span><br><span class="line"></span><br><span class="line">	HealthTextRenderComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UTextRenderComponent&gt;(<span class="string">&quot;HealthTextRenderComponent&quot;</span>);</span><br><span class="line">	HealthTextRenderComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">GetRootComponent</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//UTextRenderComponent用于血量显示。之所以使用FString转换成FText而不是直接使用FText与本地化有关</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示血量  %.0f表示精度为0位小数，即显示整数</span></span><br><span class="line">	HealthTextRenderComponent-&gt;<span class="built_in">SetText</span>(FText::<span class="built_in">FromString</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%.0f&quot;</span>), HealthComponent-&gt;<span class="built_in">GetHealth</span>())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补充：check宏，仅在develop和debug模式下使用，检测指针是否存在；在shipping模式下，将被忽略，不会影响程序运行速度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="built_in">check</span>(HealthComponent);</span><br><span class="line">	<span class="built_in">check</span>(HealthTextRenderComponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="伤害机制"><a href="#伤害机制" class="headerlink" title="伤害机制"></a>伤害机制</h1><p>UE Actor类中封装了伤害的机制：<br>·TakeDamage()中广播了OnTakeAnyDamage的委托实例(共有三种：OnTakeAnyDamage，OnTakePointDamage，OnTakeRadialDamage，这里以OnTakeAnyDamage为例)<br>·我们在伤害源的类调用TakeDamage()造成伤害，在需要的地方(如HealthComponent)定义函数，并订阅OnTakeAnyDamage委托<br>·这样伤害源造成伤害后广播委托，处理被伤害的相关函数就会被调用了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUHealthComponent.cpp</span></span><br><span class="line">	<span class="comment">//委托在Actor中，需要包含头文件&quot;GameFramework/Actor.h&quot;</span></span><br><span class="line"><span class="comment">//in STUBaseCharacter.cpp</span></span><br></pre></td></tr></table></figure>

<h1 id="角色伤害叠加机制"><a href="#角色伤害叠加机制" class="headerlink" title="角色伤害叠加机制"></a>角色伤害叠加机制</h1><p>实现手雷爆炸对角色造成伤害<br>新建一个STUDevDamageActor类</p>
<p>可视化一个爆炸模拟的球体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含头文件&quot;DrawDebugHelpers.h&quot;,每帧绘制一个球体</span></span><br><span class="line"><span class="built_in">DrawDebugSphere</span>(<span class="built_in">GetWorld</span>(), <span class="built_in">GetActorLocation</span>(), Radius, <span class="number">24</span>, DebugSphereColor);</span><br></pre></td></tr></table></figure>

<p>实现玩家进入球体时受到伤害</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含头文件&quot;Kismet/GameplayStatics.h&quot;</span></span><br><span class="line">	<span class="comment">//每一帧造成伤害</span></span><br><span class="line">UGameplayStatics::<span class="built_in">ApplyRadialDamage</span>(<span class="built_in">GetWorld</span>(), Damage, <span class="built_in">GetActorLocation</span>(), Radius, <span class="literal">nullptr</span>, &#123;&#125;, <span class="keyword">this</span>, <span class="literal">nullptr</span>, bDoFullDamage);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="036伤害类型"><a href="#036伤害类型" class="headerlink" title="036伤害类型"></a>036伤害类型</h1><h2 id="角色死亡代码部分"><a href="#角色死亡代码部分" class="headerlink" title="角色死亡代码部分"></a>角色死亡代码部分</h2><p>创建USTUFireDamageType、USTUIceDamageType类继承自UDamageType类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断传进来的DamageType指针指向哪一个对象，可以使用强制类型转换，如果成功，即该指针是指向该子类的。UE为我们准备了IsA模板函数</span></span><br></pre></td></tr></table></figure>

<h1 id="037角色生命值为0时的动画"><a href="#037角色生命值为0时的动画" class="headerlink" title="037角色生命值为0时的动画"></a>037角色生命值为0时的动画</h1><p>在STUHealthComponent中声明一个OnDie的委托，当角色死亡时广播，这样方便当角色死亡时执行其他相关功能<br>我们注意到：OnTakeAnyDamage()在HealthComponent中定义，而OnDie()在角色类中定义。<br>因为不同角色死亡后的反应不同。与角色密切相关的功能在角色类中实现，通用的功能在组件中实现。比如，与角色密切相关的功能是，角色死亡后该发生什么，因此OnDie()在角色类中定义；而通用的功能，如广播HP&lt;&#x3D;0（角色死亡），这就可以在健康组件中实现。组件中，尽量保持功能的通用性，保证可以对多个角色类复用。<br>虚幻为我们写好的OnTakeAnyDamage等委托是在Actor类中实现的，因为TakeDamage是Actor类的行为，而Health值的变化是HealthComponent的行为，所以注册OnTakeAnyDamage等委托的函数在HealthComponent中实现，即受到伤害未必会导致HP变化，而有关HP变化的逻辑就要在HealthComponent中完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUHealthComponent</span></span><br><span class="line">	<span class="comment">//声明委托和委托实例</span></span><br><span class="line"><span class="built_in">DECLARE_MULTICAST_DELEGATE</span>(FOnDie);</span><br><span class="line">FOnDie OnDie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">USTUHealthComponent::OnTakeAnyDamage</span><span class="params">(AActor * DamagedActor, <span class="type">float</span> Damage, <span class="type">const</span> UDamageType * DamageType, AController * InstigatedBy, AActor * DamageCauser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当伤害值&lt;=0 或 角色死亡(Health&lt;=0)时，才执行伤害功能</span></span><br><span class="line">	<span class="keyword">if</span> (Damage &gt; <span class="number">0</span> || !<span class="built_in">IsDead</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//避免Health值出现&lt;0 和 &gt;MaxHealth的情况</span></span><br><span class="line">		Health = FMath::<span class="built_in">Clamp</span>(Health - Damage, <span class="number">0.0f</span>, MaxHealth);</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogSTUHealthComponent, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Damage: %f&quot;</span>), Damage);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsDead</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		OnDie.<span class="built_in">Broadcast</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in STUBaseCharacter</span></span><br><span class="line">	<span class="comment">//定义OnDie()函数，并注册HealthComponent中的OnDie委托</span></span><br><span class="line">	HealthComponent-&gt;OnDie.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ASTUBaseCharacter::OnDie);</span><br></pre></td></tr></table></figure>

<h2 id="角色死亡动画部分"><a href="#角色死亡动画部分" class="headerlink" title="角色死亡动画部分"></a>角色死亡动画部分</h2><p>·因为任何状态都可以转换到死亡状态，因此使用StateMachine非常低效。可以使用AnimMontage实现，右键动画资产来创建。AnimMontage可以在代码或蓝图中直接调用进行播放。<br>·在动画蓝图中，Locomotion节点和Output Pose之间，插入Slot。当Montage播放时，对正在播放的动画进行插补(interpolation)<br>·在动画蒙太奇Blend Option中取消勾选Enable Auto Blend out，以避免死亡动画重复重复播放<br>·在动画播放完成后，禁用移动输入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁用移动输入</span></span><br></pre></td></tr></table></figure>

<p>##优化：仅在声明值改变时更新文本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in STUHealthComponent</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnHealthChanged, <span class="type">float</span>, Health);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">	FOnHealthChanged OnHealthChanged;</span><br><span class="line">	<span class="comment">//两个地方广播该委托：在游戏开始时，在Health改变时(代码略)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//in STUBaseCharacter</span></span><br><span class="line">	<span class="comment">//注意：Actor的BeginPlay()调用顺序是，先调用所有组件的BeginPlay()，再调用自身的，因此OnHealthChange()绑定委托之前，&quot;游戏开始时&quot;的委托就已经广播过了。所以需要在STUBaseCharacter的BeginPlay()中，手动显示一下生命值。</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ASTUBaseCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="built_in">check</span>(HealthComponent);</span><br><span class="line">	<span class="built_in">check</span>(HealthTextRenderComponent);</span><br><span class="line">	<span class="built_in">check</span>(<span class="built_in">GetCharacterMovement</span>());</span><br><span class="line">	<span class="comment">//此处手动显示生命值</span></span><br><span class="line">	<span class="built_in">OnHealthChanged</span>(HealthComponent-&gt;<span class="built_in">GetHealth</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册HealthComponent中的OnDie委托</span></span><br><span class="line">	HealthComponent-&gt;OnDie.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ASTUBaseCharacter::OnDie);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册HealthComponent中的OnHealthChanged委托</span></span><br><span class="line">	HealthComponent-&gt;OnHealthChanged.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;ASTUBaseCharacter::OnHealthChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="038观察者类"><a href="#038观察者类" class="headerlink" title="038观察者类"></a>038观察者类</h1></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/background.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Aozi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><div class="sticky_layout"></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Aozi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">世界，充满未解之谜……</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>